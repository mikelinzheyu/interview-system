import axios from 'axios'
import * as echarts from 'echarts'
import html2canvas from 'html2canvas'
import jsPDF from 'jspdf'

/**
 * å¤šç»´åº¦å¯è§†åŒ–æŠ¥å‘ŠæœåŠ¡
 * æä¾›äº¤äº’å¼å›¾è¡¨ã€å¤šè§’è‰²æŠ¥å‘Šå’Œå¯¼å‡ºåŠŸèƒ½
 */
export class VisualReportService {
  constructor() {
    this.chartInstances = new Map()

    this.chartTypes = {
      radarChart: {
        dimensions: 5,
        interactive: true,
        benchmarkOverlay: true,
        animations: true
      },
      timelineChart: {
        showOptimalRange: true,
        highlightLongPauses: true,
        smoothing: true
      },
      wordCloud: {
        colorByRelevance: true,
        sizeByFrequency: true,
        minFontSize: 12,
        maxFontSize: 40
      },
      skillGapMatrix: {
        industry: 'frontend',
        level: 'senior',
        recommendations: true,
        heatmapStyle: true
      },
      progressRing: {
        animated: true,
        showPercentage: true,
        colorGradient: true
      }
    }

    this.exportEngine = {
      formats: ['PDF', 'PNG', 'SVG', 'HTML'],
      templates: {
        candidate: {
          name: 'detailed-feedback',
          sections: ['summary', 'dimensions', 'suggestions', 'timeline'],
          branding: { showLogo: true, primaryColor: '#409eff' }
        },
        hr: {
          name: 'summary-report',
          sections: ['overview', 'scoreComparison', 'recommendations'],
          branding: { showLogo: true, primaryColor: '#67c23a' }
        },
        interviewer: {
          name: 'analysis-deep-dive',
          sections: ['detailed', 'evidence', 'technical', 'comparisons'],
          branding: { showLogo: false, primaryColor: '#e6a23c' }
        }
      },
      branding: {
        customizable: true,
        logoPosition: 'top-right',
        footerText: 'Generated by AI Interview System'
      }
    }

    this.industryBenchmarks = {
      frontend: {
        junior: { technical: 65, completeness: 70, logic: 68, professional: 60, fluency: 72 },
        mid: { technical: 75, completeness: 80, logic: 78, professional: 75, fluency: 82 },
        senior: { technical: 85, completeness: 88, logic: 86, professional: 88, fluency: 90 }
      },
      backend: {
        junior: { technical: 70, completeness: 68, logic: 75, professional: 65, fluency: 70 },
        mid: { technical: 80, completeness: 78, logic: 82, professional: 78, fluency: 80 },
        senior: { technical: 88, completeness: 85, logic: 87, professional: 85, fluency: 88 }
      },
      fullstack: {
        junior: { technical: 68, completeness: 69, logic: 72, professional: 63, fluency: 71 },
        mid: { technical: 78, completeness: 79, logic: 80, professional: 77, fluency: 81 },
        senior: { technical: 87, completeness: 87, logic: 87, professional: 87, fluency: 89 }
      }
    }
  }

  /**
   * ç”Ÿæˆå®Œæ•´çš„å¯è§†åŒ–æŠ¥å‘Š
   */
  async generateVisualReport(analysisData, reportType = 'candidate', exportFormat = null) {
    try {
      console.log('ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š:', { reportType, exportFormat })

      const reportData = await this.processAnalysisData(analysisData)
      const visualComponents = await this.createVisualComponents(reportData, reportType)
      const reportHtml = await this.assembleReport(visualComponents, reportType)

      if (exportFormat) {
        return await this.exportReport(reportHtml, exportFormat, reportType)
      }

      return {
        html: reportHtml,
        components: visualComponents,
        metadata: {
          generatedAt: Date.now(),
          reportType,
          version: '2.0'
        }
      }

    } catch (error) {
      console.error('ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Šå¤±è´¥:', error)
      return this.createFallbackReport(analysisData, error)
    }
  }

  /**
   * åˆ›å»ºäº”ç»´åº¦é›·è¾¾å›¾
   */
  createRadarChart(container, data, options = {}) {
    const defaultOptions = {
      ...this.chartTypes.radarChart,
      ...options
    }

    const chartConfig = {
      title: {
        text: 'äº”ç»´åº¦èƒ½åŠ›åˆ†æ',
        left: 'center',
        textStyle: {
          fontSize: 18,
          fontWeight: 'bold',
          color: '#333'
        }
      },
      tooltip: {
        trigger: 'item',
        formatter: function(params) {
          return `${params.name}: ${params.value}åˆ†`
        }
      },
      legend: {
        data: ['å½“å‰å¾—åˆ†', 'è¡Œä¸šå¹³å‡', 'ç›®æ ‡æ°´å¹³'],
        bottom: 10,
        textStyle: { fontSize: 12 }
      },
      radar: {
        indicator: [
          { name: 'æŠ€æœ¯å‡†ç¡®æ€§', max: 100 },
          { name: 'å®Œæ•´æ€§', max: 100 },
          { name: 'é€»è¾‘æ¸…æ™°åº¦', max: 100 },
          { name: 'ä¸“ä¸šæœ¯è¯­', max: 100 },
          { name: 'è¡¨è¾¾æµç•…æ€§', max: 100 }
        ],
        shape: 'polygon',
        splitNumber: 5,
        name: {
          textStyle: { fontSize: 12, color: '#666' }
        },
        splitLine: {
          lineStyle: { color: 'rgba(0,0,0,0.1)' }
        },
        splitArea: {
          show: true,
          areaStyle: {
            color: ['rgba(114, 172, 209, 0.1)', 'rgba(114, 172, 209, 0.05)']
          }
        }
      },
      series: [{
        name: 'èƒ½åŠ›è¯„ä¼°',
        type: 'radar',
        data: [
          {
            value: [
              data.technicalAccuracy || 0,
              data.completeness || 0,
              data.logicClarity || 0,
              data.professionalTerms || 0,
              data.fluency || 0
            ],
            name: 'å½“å‰å¾—åˆ†',
            itemStyle: { color: '#409eff' },
            areaStyle: { color: 'rgba(64, 158, 255, 0.2)' }
          },
          {
            value: this.getBenchmarkScores(data.position, data.level),
            name: 'è¡Œä¸šå¹³å‡',
            itemStyle: { color: '#67c23a' },
            areaStyle: { color: 'rgba(103, 194, 58, 0.1)' }
          }
        ]
      }],
      animation: defaultOptions.animations,
      animationDuration: 1000,
      animationEasing: 'cubicOut'
    }

    const chart = echarts.init(container)
    chart.setOption(chartConfig)

    // æ·»åŠ äº¤äº’äº‹ä»¶
    if (defaultOptions.interactive) {
      chart.on('click', (params) => {
        this.handleRadarChartClick(params, data)
      })
    }

    this.chartInstances.set(container.id, chart)
    return chart
  }

  /**
   * åˆ›å»ºå›ç­”æ—¶é—´çº¿å›¾è¡¨
   */
  createTimelineChart(container, timelineData, options = {}) {
    const defaultOptions = {
      ...this.chartTypes.timelineChart,
      ...options
    }

    const chartConfig = {
      title: {
        text: 'å›ç­”æ—¶é—´åˆ†æ',
        left: 'center',
        textStyle: { fontSize: 16, fontWeight: 'bold' }
      },
      tooltip: {
        trigger: 'axis',
        formatter: function(params) {
          const point = params[0]
          return `é—®é¢˜ ${point.dataIndex + 1}<br/>
                  å›ç­”æ—¶é•¿: ${point.value}ç§’<br/>
                  ${point.value > 120 ? 'âš ï¸ è¶…æ—¶' : point.value < 30 ? 'âš¡ å¾ˆå¿«' : 'âœ… æ­£å¸¸'}`
        }
      },
      grid: {
        left: '10%',
        right: '10%',
        bottom: '15%',
        top: '20%'
      },
      xAxis: {
        type: 'category',
        data: timelineData.questions,
        axisLabel: { fontSize: 10, rotate: 45 }
      },
      yAxis: {
        type: 'value',
        name: 'æ—¶é—´(ç§’)',
        axisLabel: { formatter: '{value}s' }
      },
      series: [
        {
          name: 'å›ç­”æ—¶é•¿',
          type: 'line',
          data: timelineData.responseTimes,
          smooth: defaultOptions.smoothing,
          itemStyle: { color: '#409eff' },
          lineStyle: { width: 3 },
          areaStyle: { color: 'rgba(64, 158, 255, 0.1)' }
        }
      ]
    }

    // æ·»åŠ æœ€ä½³æ—¶é—´èŒƒå›´æ ‡è®°
    if (defaultOptions.showOptimalRange) {
      chartConfig.series.push({
        name: 'æœ€ä½³èŒƒå›´',
        type: 'line',
        data: timelineData.questions.map(() => 60),
        lineStyle: { color: '#67c23a', type: 'dashed' },
        symbol: 'none',
        silent: true
      })
    }

    // é«˜äº®é•¿æ—¶é—´åœé¡¿
    if (defaultOptions.highlightLongPauses) {
      const longPauses = timelineData.responseTimes.map((time, index) =>
        time > 120 ? { value: time, itemStyle: { color: '#f56c6c' }} : time
      )
      chartConfig.series[0].data = longPauses
    }

    const chart = echarts.init(container)
    chart.setOption(chartConfig)
    this.chartInstances.set(container.id, chart)
    return chart
  }

  /**
   * åˆ›å»ºè¯äº‘å›¾
   */
  createWordCloud(container, wordsData, options = {}) {
    const defaultOptions = {
      ...this.chartTypes.wordCloud,
      ...options
    }

    // è½¬æ¢è¯äº‘æ•°æ®æ ¼å¼
    const cloudData = wordsData.map(word => ({
      name: word.text,
      value: word.frequency,
      textStyle: {
        color: defaultOptions.colorByRelevance ?
          this.getRelevanceColor(word.relevance) :
          this.getRandomColor(),
        fontSize: defaultOptions.sizeByFrequency ?
          this.calculateFontSize(word.frequency, defaultOptions) :
          16
      }
    }))

    const chartConfig = {
      title: {
        text: 'å…³é”®è¯ä½¿ç”¨åˆ†æ',
        left: 'center',
        textStyle: { fontSize: 16, fontWeight: 'bold' }
      },
      series: [{
        type: 'wordCloud',
        shape: 'circle',
        width: '90%',
        height: '90%',
        sizeRange: [defaultOptions.minFontSize, defaultOptions.maxFontSize],
        rotationRange: [-45, 45],
        rotationStep: 45,
        gridSize: 8,
        drawOutOfBound: false,
        textStyle: {
          fontFamily: 'Arial, sans-serif',
          fontWeight: 'bold'
        },
        data: cloudData
      }]
    }

    const chart = echarts.init(container)
    chart.setOption(chartConfig)
    this.chartInstances.set(container.id, chart)
    return chart
  }

  /**
   * åˆ›å»ºæŠ€èƒ½ç¼ºå£çŸ©é˜µ
   */
  createSkillGapMatrix(container, skillsData, options = {}) {
    const defaultOptions = {
      ...this.chartTypes.skillGapMatrix,
      ...options
    }

    const matrixData = this.processSkillGapData(skillsData, defaultOptions)

    const chartConfig = {
      title: {
        text: 'æŠ€èƒ½ç¼ºå£åˆ†æ',
        left: 'center',
        textStyle: { fontSize: 16, fontWeight: 'bold' }
      },
      tooltip: {
        position: 'top',
        formatter: function(params) {
          return `${params.data[2]}æŠ€èƒ½: ${params.data[0]}<br/>
                  å½“å‰æ°´å¹³: ${params.data[1]}%<br/>
                  ${params.data[1] < 70 ? 'ğŸ”´ éœ€è¦æå‡' : params.data[1] < 85 ? 'ğŸŸ¡ è‰¯å¥½' : 'ğŸŸ¢ ä¼˜ç§€'}`
        }
      },
      grid: {
        height: '60%',
        top: '15%',
        left: '20%'
      },
      xAxis: {
        type: 'category',
        data: matrixData.categories,
        splitArea: { show: true },
        axisLabel: { fontSize: 10 }
      },
      yAxis: {
        type: 'category',
        data: matrixData.skills,
        splitArea: { show: true },
        axisLabel: { fontSize: 10 }
      },
      visualMap: {
        min: 0,
        max: 100,
        calculable: true,
        orient: 'horizontal',
        left: 'center',
        bottom: '10%',
        inRange: {
          color: ['#d94e5d', '#eac736', '#50a3ba']
        }
      },
      series: [{
        name: 'æŠ€èƒ½æ°´å¹³',
        type: 'heatmap',
        data: matrixData.data,
        label: {
          show: true,
          formatter: '{c}%',
          fontSize: 10
        },
        emphasis: {
          itemStyle: { shadowBlur: 10, shadowColor: 'rgba(0, 0, 0, 0.5)' }
        }
      }]
    }

    const chart = echarts.init(container)
    chart.setOption(chartConfig)
    this.chartInstances.set(container.id, chart)
    return chart
  }

  /**
   * åˆ›å»ºè¿›åº¦ç¯å›¾
   */
  createProgressRing(container, progressData, options = {}) {
    const defaultOptions = {
      ...this.chartTypes.progressRing,
      ...options
    }

    const chartConfig = {
      title: {
        text: `${progressData.label}\n${progressData.value}%`,
        left: 'center',
        top: 'middle',
        textStyle: {
          fontSize: 20,
          fontWeight: 'bold',
          color: progressData.color || '#409eff'
        }
      },
      series: [{
        type: 'pie',
        radius: ['60%', '80%'],
        avoidLabelOverlap: false,
        hoverAnimation: false,
        label: { show: false },
        labelLine: { show: false },
        data: [
          {
            value: progressData.value,
            itemStyle: {
              color: defaultOptions.colorGradient ? {
                type: 'linear',
                x: 0, y: 0, x2: 0, y2: 1,
                colorStops: [
                  { offset: 0, color: progressData.color || '#409eff' },
                  { offset: 1, color: progressData.colorEnd || '#66b1ff' }
                ]
              } : progressData.color || '#409eff'
            }
          },
          {
            value: 100 - progressData.value,
            itemStyle: { color: '#f0f0f0' },
            silent: true
          }
        ]
      }],
      animation: defaultOptions.animated,
      animationType: 'scale',
      animationEasing: 'elasticOut',
      animationDelay: function(idx) { return idx * 100 }
    }

    const chart = echarts.init(container)
    chart.setOption(chartConfig)
    this.chartInstances.set(container.id, chart)
    return chart
  }

  /**
   * å¯¼å‡ºæŠ¥å‘Š
   */
  async exportReport(reportHtml, format, reportType) {
    try {
      switch (format.toLowerCase()) {
        case 'pdf':
          return await this.exportToPDF(reportHtml, reportType)
        case 'png':
          return await this.exportToPNG(reportHtml)
        case 'svg':
          return await this.exportToSVG(reportHtml)
        case 'html':
          return this.exportToHTML(reportHtml, reportType)
        default:
          throw new Error(`ä¸æ”¯æŒçš„å¯¼å‡ºæ ¼å¼: ${format}`)
      }
    } catch (error) {
      console.error('æŠ¥å‘Šå¯¼å‡ºå¤±è´¥:', error)
      throw error
    }
  }

  /**
   * å¯¼å‡ºä¸ºPDF
   */
  async exportToPDF(reportHtml, reportType) {
    try {
      // åˆ›å»ºä¸´æ—¶å®¹å™¨
      const tempContainer = document.createElement('div')
      tempContainer.innerHTML = reportHtml
      tempContainer.style.position = 'absolute'
      tempContainer.style.left = '-9999px'
      tempContainer.style.width = '210mm' // A4å®½åº¦
      document.body.appendChild(tempContainer)

      // æ¸²æŸ“å›¾è¡¨
      await this.renderChartsInContainer(tempContainer)

      // è½¬æ¢ä¸ºCanvas
      const canvas = await html2canvas(tempContainer, {
        scale: 2,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff'
      })

      // åˆ›å»ºPDF
      const pdf = new jsPDF('p', 'mm', 'a4')
      const imgData = canvas.toDataURL('image/png')
      const imgWidth = 210
      const pageHeight = 295
      const imgHeight = (canvas.height * imgWidth) / canvas.width
      let heightLeft = imgHeight

      let position = 0
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight)
      heightLeft -= pageHeight

      while (heightLeft >= 0) {
        position = heightLeft - imgHeight
        pdf.addPage()
        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight)
        heightLeft -= pageHeight
      }

      // æ¸…ç†ä¸´æ—¶å®¹å™¨
      document.body.removeChild(tempContainer)

      const pdfBlob = pdf.output('blob')
      const fileName = `interview-report-${reportType}-${Date.now()}.pdf`

      return {
        blob: pdfBlob,
        fileName,
        downloadUrl: URL.createObjectURL(pdfBlob)
      }

    } catch (error) {
      console.error('PDFå¯¼å‡ºå¤±è´¥:', error)
      throw error
    }
  }

  /**
   * å¯¼å‡ºä¸ºPNG
   */
  async exportToPNG(reportHtml) {
    const tempContainer = document.createElement('div')
    tempContainer.innerHTML = reportHtml
    tempContainer.style.position = 'absolute'
    tempContainer.style.left = '-9999px'
    tempContainer.style.backgroundColor = '#ffffff'
    document.body.appendChild(tempContainer)

    try {
      await this.renderChartsInContainer(tempContainer)

      const canvas = await html2canvas(tempContainer, {
        scale: 2,
        useCORS: true,
        allowTaint: true
      })

      document.body.removeChild(tempContainer)

      return new Promise(resolve => {
        canvas.toBlob(blob => {
          const fileName = `interview-report-${Date.now()}.png`
          resolve({
            blob,
            fileName,
            downloadUrl: URL.createObjectURL(blob)
          })
        }, 'image/png', 1.0)
      })

    } catch (error) {
      document.body.removeChild(tempContainer)
      throw error
    }
  }

  /**
   * å¯¼å‡ºä¸ºHTML
   */
  exportToHTML(reportHtml, reportType) {
    const template = this.exportEngine.templates[reportType]
    const branding = template.branding

    const completeHtml = `
      <!DOCTYPE html>
      <html lang="zh-CN">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>é¢è¯•åˆ†ææŠ¥å‘Š</title>
        <style>
          body { font-family: 'Arial', sans-serif; margin: 0; padding: 20px; }
          .report-container { max-width: 1200px; margin: 0 auto; }
          .report-header { text-align: center; margin-bottom: 30px; }
          .report-footer { margin-top: 50px; text-align: center; font-size: 12px; color: #666; }
          ${branding.showLogo ? '.logo { margin-bottom: 20px; }' : ''}
        </style>
      </head>
      <body>
        <div class="report-container">
          ${branding.showLogo ? '<div class="logo">ğŸ¤– AI Interview System</div>' : ''}
          ${reportHtml}
          <div class="report-footer">
            ${this.exportEngine.branding.footerText} | Generated at ${new Date().toLocaleString()}
          </div>
        </div>
      </body>
      </html>
    `

    const blob = new Blob([completeHtml], { type: 'text/html' })
    const fileName = `interview-report-${reportType}-${Date.now()}.html`

    return {
      blob,
      fileName,
      downloadUrl: URL.createObjectURL(blob)
    }
  }

  // è¾…åŠ©æ–¹æ³•

  async processAnalysisData(analysisData) {
    return {
      scores: {
        technicalAccuracy: analysisData.technicalAccuracy || 0,
        completeness: analysisData.completeness || 0,
        logicClarity: analysisData.logicClarity || 0,
        professionalTerms: analysisData.professionalTerms || 0,
        fluency: analysisData.fluency || 0,
        overall: analysisData.overallScore || 0
      },
      metadata: {
        position: analysisData.position || 'unknown',
        level: analysisData.level || 'mid',
        duration: analysisData.duration || 0,
        questionCount: analysisData.questionCount || 0
      },
      timeline: analysisData.timeline || [],
      keywords: analysisData.keywords || [],
      skills: analysisData.skills || []
    }
  }

  async createVisualComponents(reportData, reportType) {
    const components = {
      radarChart: null,
      timelineChart: null,
      wordCloud: null,
      skillMatrix: null,
      progressRings: []
    }

    const template = this.exportEngine.templates[reportType]

    if (template.sections.includes('dimensions')) {
      components.radarChart = this.generateRadarChartHtml(reportData.scores)
    }

    if (template.sections.includes('timeline') && reportData.timeline.length > 0) {
      components.timelineChart = this.generateTimelineChartHtml(reportData.timeline)
    }

    if (reportData.keywords.length > 0) {
      components.wordCloud = this.generateWordCloudHtml(reportData.keywords)
    }

    if (reportData.skills.length > 0) {
      components.skillMatrix = this.generateSkillMatrixHtml(reportData.skills)
    }

    // åˆ›å»ºè¿›åº¦ç¯
    Object.keys(reportData.scores).forEach(dimension => {
      if (dimension !== 'overall') {
        components.progressRings.push({
          id: `progress-${dimension}`,
          data: {
            label: this.getDimensionLabel(dimension),
            value: reportData.scores[dimension],
            color: this.getDimensionColor(dimension)
          }
        })
      }
    })

    return components
  }

  async assembleReport(visualComponents, reportType) {
    const template = this.exportEngine.templates[reportType]
    let reportHtml = '<div class="visual-report">'

    if (template.sections.includes('summary')) {
      reportHtml += this.generateSummarySection(visualComponents)
    }

    if (template.sections.includes('dimensions')) {
      reportHtml += this.generateDimensionsSection(visualComponents)
    }

    if (template.sections.includes('timeline')) {
      reportHtml += this.generateTimelineSection(visualComponents)
    }

    if (template.sections.includes('suggestions')) {
      reportHtml += this.generateSuggestionsSection(visualComponents)
    }

    reportHtml += '</div>'
    return reportHtml
  }

  getBenchmarkScores(position, level) {
    const benchmark = this.industryBenchmarks[position] || this.industryBenchmarks.frontend
    const levelData = benchmark[level] || benchmark.mid

    return [
      levelData.technical,
      levelData.completeness,
      levelData.logic,
      levelData.professional,
      levelData.fluency
    ]
  }

  getRelevanceColor(relevance) {
    if (relevance > 0.8) return '#67c23a'
    if (relevance > 0.6) return '#e6a23c'
    if (relevance > 0.4) return '#f56c6c'
    return '#909399'
  }

  getRandomColor() {
    const colors = ['#409eff', '#67c23a', '#e6a23c', '#f56c6c', '#909399']
    return colors[Math.floor(Math.random() * colors.length)]
  }

  calculateFontSize(frequency, options) {
    const range = options.maxFontSize - options.minFontSize
    return Math.max(options.minFontSize, options.minFontSize + (frequency * range))
  }

  getDimensionLabel(dimension) {
    const labels = {
      technicalAccuracy: 'æŠ€æœ¯å‡†ç¡®æ€§',
      completeness: 'å®Œæ•´æ€§',
      logicClarity: 'é€»è¾‘æ¸…æ™°åº¦',
      professionalTerms: 'ä¸“ä¸šæœ¯è¯­',
      fluency: 'è¡¨è¾¾æµç•…æ€§'
    }
    return labels[dimension] || dimension
  }

  getDimensionColor(dimension) {
    const colors = {
      technicalAccuracy: '#409eff',
      completeness: '#67c23a',
      logicClarity: '#e6a23c',
      professionalTerms: '#f56c6c',
      fluency: '#909399'
    }
    return colors[dimension] || '#409eff'
  }

  /**
   * æ¸…ç†æ‰€æœ‰å›¾è¡¨å®ä¾‹
   */
  cleanup() {
    this.chartInstances.forEach(chart => {
      if (chart && typeof chart.dispose === 'function') {
        chart.dispose()
      }
    })
    this.chartInstances.clear()
  }
}

export default new VisualReportService()