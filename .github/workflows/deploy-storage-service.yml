# GitHub Actions 工作流 - 自动构建和部署存储服务
# 当代码推送到 main 分支时，自动构建 Docker 镜像并部署到云服务器

name: Deploy Storage Service to Cloud

on:
  push:
    branches:
      - main
    paths:
      - 'storage-service/**'
      - '.github/workflows/deploy-storage-service.yml'
  workflow_dispatch:  # 允许手动触发

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}/storage-service

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      # 1. 检出代码
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # 2. 设置 Java
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      # 3. 构建 JAR 文件
      - name: Build with Maven
        run: |
          cd storage-service
          mvn clean package -DskipTests -q

      # 4. 构建 Docker 镜像
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker image
        run: |
          cd storage-service
          docker build -f Dockerfile.prod -t storage-service:${{ github.sha }} -t storage-service:latest .

      # 5. 部署到云服务器（通过SSH）
      - name: Deploy to cloud server
        env:
          CLOUD_SERVER_IP: ${{ secrets.CLOUD_SERVER_IP }}
          CLOUD_SERVER_USER: ${{ secrets.CLOUD_SERVER_USER }}
          CLOUD_SERVER_KEY: ${{ secrets.CLOUD_SERVER_KEY }}
          STORAGE_API_KEY: ${{ secrets.STORAGE_API_KEY }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
        run: |
          # 创建 SSH 密钥
          mkdir -p ~/.ssh
          echo "$CLOUD_SERVER_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $CLOUD_SERVER_IP >> ~/.ssh/known_hosts

          # 部署脚本
          ssh -i ~/.ssh/id_rsa $CLOUD_SERVER_USER@$CLOUD_SERVER_IP << 'EOF'
          set -e

          # 进入项目目录
          cd /home/interview-system || mkdir -p /home/interview-system && cd /home/interview-system

          # 克隆或更新仓库
          if [ -d ".git" ]; then
            git pull origin main
          else
            git clone https://github.com/${{ github.repository }}.git .
          fi

          # 进入存储服务目录
          cd storage-service

          # 配置环境变量
          cat > .env.prod << ENDENV
          REDIS_PASSWORD=$REDIS_PASSWORD
          STORAGE_API_KEY=$STORAGE_API_KEY
          SPRING_PROFILES_ACTIVE=prod
          SERVER_PORT=8081
          SPRING_REDIS_HOST=interview-redis
          SPRING_REDIS_PORT=6379
          TZ=Asia/Shanghai
          JAVA_OPTS=-Xms512m -Xmx1024m -XX:+UseG1GC
          ENDENV

          # 重新构建 Docker 镜像（使用云服务器的maven缓存）
          docker-compose -f docker-compose-prod.yml build
          docker-compose -f docker-compose-prod.yml up -d

          # 等待服务启动
          sleep 10

          # 健康检查
          curl -f -H "Authorization: Bearer $STORAGE_API_KEY" http://localhost:8081/api/sessions || exit 1

          echo "✅ 存储服务已成功部署！"
          EOF

      # 6. 健康检查
      - name: Health check
        env:
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
          STORAGE_API_KEY: ${{ secrets.STORAGE_API_KEY }}
        run: |
          sleep 15
          curl -f -H "Authorization: Bearer $STORAGE_API_KEY" https://$DOMAIN_NAME/api/sessions || exit 1
          echo "✅ 云服务器存储服务健康检查通过"

      # 7. 失败通知（可选）
      - name: Notify failure
        if: failure()
        run: |
          echo "❌ 部署失败！请检查日志"
          exit 1

  # 并行任务：健康检查
  health-check:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: success()

    steps:
      - name: Check storage service health
        env:
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
          STORAGE_API_KEY: ${{ secrets.STORAGE_API_KEY }}
        run: |
          for i in {1..5}; do
            echo "Health check attempt $i..."
            if curl -f -H "Authorization: Bearer $STORAGE_API_KEY" https://$DOMAIN_NAME/api/sessions; then
              echo "✅ 服务健康"
              exit 0
            fi
            sleep 5
          done
          echo "❌ 服务不可达"
          exit 1
